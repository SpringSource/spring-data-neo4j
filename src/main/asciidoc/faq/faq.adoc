[[faq]]
= Frequently Asked Questions

Here are a couple of more frequently asked question in addition to the ones in the <<what-is-sdn,preface>>.

[[faq.multidatabase]]
== Neo4j 4.0 supports multiple databases - How can I use them?

You can either statically configure the database name or run your own database name provider.
Bear in mind that SDN will not create the databases for you.
You can do this with the help of a https://github.com/michael-simons/neo4j-migrations[migrations tool]
or of course with a simple script upfront.

[[faq.multidatabase.statically]]
=== Statically configured

Configure the database name to use in your Spring Boot configuration like this (the same property applies of course for YML or environment based configuration, with Spring Boot's conventions applied):

[source,properties]
----
spring.data.neo4j.database = yourDatabase
----

With that configuration in place, all queries generated by all instances of SDN repositories (both reactive and imperative) and by the `ReactiveNeo4jTemplate` respectively `Neo4jTemplate` will be executed against the database `yourDatabase`.

[[faq.multidatabase.dynamically]]
=== Dynamically configured

Provide a bean with the type `Neo4jDatabaseNameProvider` or `ReactiveDatabaseSelectionProvider` depending on the type of your Spring application.

That bean could use for example Spring's security context to retrieve a tenant.
Here is a working example for an imperative application secured with Spring Security:

[source,java]
[[faq.databaseSelectionProvider]]
.Neo4jConfig.java
----
import org.neo4j.springframework.data.core.DatabaseSelection;
import org.neo4j.springframework.data.core.DatabaseSelectionProvider;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;

include::../../../../src/test/java/org/springframework/data/neo4j/documentation/Neo4jConfig.java[tags=faq.multidatabase]
----

NOTE: Be careful that you don't mix up entities retrieved from one database with another database.
The database name is requested for each new transaction, so you might end up with less or more entities than expected when changing the database name in between calls.
Or worse, you could inevitably store the wrong entities in the wrong database.

[[faq.transactions.cluster]]
== Do I need specific configuration so that transactions work seamless with a Neo4j Causal Cluster?

No, you don't.
SDN uses Neo4j Causal Cluster bookmarks internally without any configuration on your side required.
Transactions in the same thread or the same reactive stream following each other will be able to read their previously changed values as you would expect.

[[faq.annotations.specific]]
== Do I need to use Neo4j specific annotations?

No.
You are free to use the following, equivalent Spring Data annotations:

[cols="4*",options="header"]
|===

|SDN specific annotation
|Spring Data common annotation
|Purpose
|Difference

|`org.springframework.data.neo4j.core.schema.Id`
|`org.springframework.data.annotation.Id`
|Marks the annotated attribute as the unique id.
|Specific annotation has no additional features.

|`org.springframework.data.neo4j.core.schema.Node`
|`org.springframework.data.annotation.Persistent`
|Marks the class as persistent entity.
|`@Node` allows customizing the labels

|===

[[faq.ids.assignment]]
== How do I use assigned ids?

Just use `@Id` without `@GeneratedValue` and fill your id attribute via a constructor parameter or a setter or _wither_.
See this https://medium.com/neo4j/neo4j-ogm-and-spring-data-neo4j-a55a866df68c[blog post] for some general remarks about finding good ids.

[[faq.ids.externally]]
== How do I use externally generated ids?

We provide the interface `org.springframework.data.neo4j.core.schema.IdGenerator`.
Implement it in any way you want and configure your implementation like this:

[source,java]
.ThingWithGeneratedId.java
----
@Node
public class ThingWithGeneratedId {

	@Id @GeneratedValue(TestSequenceGenerator.class)
	private String theId;
}
----

If you pass in the name of a class to `@GeneratedValue`, this class must have a no-args default constructor.
You can however use a string as well:

[source,java]
.ThingWithIdGeneratedByBean.java
----
@Node
public class ThingWithIdGeneratedByBean {

	@Id @GeneratedValue(generatorRef = "idGeneratingBean")
	private String theId;
}
----

With that, `idGeneratingBean` refers to a bean in the Spring context.
This might be useful for sequence generating.

NOTE: Setters are not required on non-final fields for the id.

[[template-support]]
== Do I have to create repositories for each domain class?

No.
Have a look at the <<sdn-building-blocks, SDN building blocks>> and find the `Neo4jTemplate` or the `ReactiveNeo4jTemplate`.

Those templates know your domain and provide all necessary basic CRUD methods for retrieving, writing and counting entities.

This is our canonical movie example with the imperative template:

[source,java]
[[imperative-template-example]]
.TemplateExampleTest.java
----
include::../../../../src/test/java/org/springframework/data/neo4j/documentation/spring_boot/TemplateExampleTest.java[tags=faq.template-imperative]
----

And here is the reactive version, omitting the setup for brevity:

[source,java]
[[reactive-template-example]]
.ReactiveTemplateExampleTest.java
----
include::../../../../src/test/java/org/springframework/data/neo4j/documentation/spring_boot/ReactiveTemplateExampleTest.java[tags=faq.template-reactive]
----

[[faq.parameters.custom-query]]
== How do I specify parameters in custom queries?

You do this exactly the same way as in a standard Cypher query issued in the Neo4j Browser or the Cypher-Shell, with the `$` syntax (from Neo4j 4.0 on upwards, the old `{foo}` syntax for Cypher parameters has been removed from the database);

[source,java,indent=0]
[[custom-queries-with-parameters]]
.ARepository.java
----
include::../../../../src/test/java/org/springframework/data/neo4j/documentation/repositories/domain_events/ARepository.java[tags=standard-parameter]
----
<.> Here we are referring to the parameter by its name.
You can also use `$0` etc. instead.

NOTE: You need to compile your Java 8+ project with `-parameters` to make named parameters work without further annotations.
The Spring Boot Maven and Gradle plugins do this automatically for you.
If this is not feasible for any reason, you can either add
`@Param`  and specify the name explicitly or use the parameters index.

Mapped entitiess (everything with a `@Node`) passed as parameter to a function that is annotated with
a custom query will be turned into a nested map. The following example represents the structure as Neo4j parameters.

Given are a `Movie`, `Person` and `Actor` classes annotated as shown in <<movie-model, the movie model>>:

[[movie-model]]
[source,java]
."Standard" movies model
----
@Node
public final class Movie {

    @Id
    private final String title;

    @Property("tagline")
    private final String description;

    @Relationship(value = "ACTED_IN", direction = Direction.INCOMING)
    private final List<Actor> actors;

    @Relationship(value = "DIRECTED", direction = Direction.INCOMING)
    private final List<Person> directors;
}

@Node
public final class Person {

    @Id @GeneratedValue
    private final Long id;

    private final String name;

    private Integer born;

    @Relationship("REVIEWED")
    private List<Movie> reviewed = new ArrayList<>();
}

@RelationshipProperties
public final class Actor {

    @TargetNode
    private final Person person;

    private final List<String> roles;
}

interface MovieRepository extends Neo4jRepository<Movie, String> {

    @Query("MATCH (m:Movie {title: $movie.__id__})\n"
           + "MATCH (m) <- [r:DIRECTED|REVIEWED|ACTED_IN] - (p:Person)\n"
           + "return m, collect(r), collect(p)")
    Movie findByMovie(@Param("movie") Movie movie);
}
----

Passing an instance of `Movie` to the repository method above, will generate the following Neo4j map parameter:

[source,json]
----
{
  "movie": {
    "__labels__": [
      "Movie"
    ],
    "__id__": "The Da Vinci Code",
    "__properties__": {
      "ACTED_IN": [
        {
          "__properties__": {
            "roles": [
              "Sophie Neveu"
            ]
          },
          "__target__": {
            "__labels__": [
              "Person"
            ],
            "__id__": 402,
            "__properties__": {
              "name": "Audrey Tautou",
              "born": 1976
            }
          }
        },
        {
          "__properties__": {
            "roles": [
              "Sir Leight Teabing"
            ]
          },
          "__target__": {
            "__labels__": [
              "Person"
            ],
            "__id__": 401,
            "__properties__": {
              "name": "Ian McKellen",
              "born": 1939
            }
          }
        },
        {
          "__properties__": {
            "roles": [
              "Dr. Robert Langdon"
            ]
          },
          "__target__": {
            "__labels__": [
              "Person"
            ],
            "__id__": 360,
            "__properties__": {
              "name": "Tom Hanks",
              "born": 1956
            }
          }
        },
        {
          "__properties__": {
            "roles": [
              "Silas"
            ]
          },
          "__target__": {
            "__labels__": [
              "Person"
            ],
            "__id__": 403,
            "__properties__": {
              "name": "Paul Bettany",
              "born": 1971
            }
          }
        }
      ],
      "DIRECTED": [
        {
          "__labels__": [
            "Person"
          ],
          "__id__": 404,
          "__properties__": {
            "name": "Ron Howard",
            "born": 1954
          }
        }
      ],
      "tagline": "Break The Codes",
      "released": 2006
    }
  }
}
----

A node is represented by a map. The map will always contain `__id__`  which is the mapped id property.
Under `__labels__` all labels, static and dynamic, will be available.
All properties - and type of relationships - appear in those maps as they would appear in the graph when the entity would
have been written by SDN.
Values will have the correct Cypher type and won't need further conversion.

All relationships are lists of maps. Dynamic relationships will be resolved accordingly.
When an entity has a relationship with the same type to different types of others nodes they will all apear in the same list.
If you need such a mapping and also have the need to work with those custom parameters, you have to unroll it accordingly.
One way to do this are correlated subqueries (Neo4j 4.1+ required).


[[faq.custom-queries]]
== How do I use custom queries with repository methods returning `Page<T>` or `Slice<T>`?

While you don't have to provide anything else apart a `Pageable` as a parameter on derived finder methods
that return a `Page<T>` or a `Slice<T>`, you must prepare your custom query to handle the pageable.
<<custom-queries-with-page-and-slice-examples>> gives you an overview about what's needed.

[[custom-queries-with-page-and-slice-examples]]
[source,java]
.Pages and Slices
----
import org.springframework.data.domain.Pageable;
import org.springframework.data.neo4j.repository.Neo4jRepository;
import org.springframework.data.neo4j.repository.query.Query;

public interface MyPersonRepository extends Neo4jRepository<Person, Long> {

    Page<Person> findByName(String name, Pageable pageable); // <.>

    @Query(""
        + "MATCH (n:Person) WHERE n.name = $name RETURN n "
        + "ORDER BY n.name ASC SKIP $skip LIMIT $limit"
    )
    Slice<Person> findSliceByName(String name, Pageable pageable); // <.>

    @Query(
    	value = ""
            + "MATCH (n:Person) WHERE n.name = $name RETURN n "
            + "ORDER BY n.name ASC SKIP $skip LIMIT $limit",
        countQuery = ""
            + "MATCH (n:Person) WHERE n.name = $name RETURN count(n)"
    )
    Page<Person> findPageByName(String name, Pageable pageable); // <.>
}
----
<.> A derived finder method that creates a query for you.
    It handles the `Pageable` for you.
    You should use a sorted pageable.
<.> This method uses `@Query` to define a custom query. It returns a `Slice<Person>`.
    A slice does not know about the total number of pages, so the custom query
    doesn't need a dedicated count query. SDN will notify you that it estimates the next slice.
    The Cypher template must spot both `$skip` and `$limit` Cypher parameter.
    If you omit them, SDN will issue a warning. The will probably not match your expectations.
    Also, the `Pageable` should be unsorted and you should provide a stable order.
    We won't use the sorting information from the pageable.
<.> This method returns a page. A page knows about the exact number of total pages.
    Therefore you must specify an additional count query.
    All other restrictions from the second method apply.

[[faq.spel.custom-query]]
== How do I use Spring Expression Language in custom queries?

{spring-framework-ref}/core.html#expressions[Spring Expression Language (SpEL)] can be used in custom queries inside `:#{}`.
This is the standard Spring Data way of defining a block of text inside a query that undergoes SpEL evaluation.

The following example basically defines the same query as above, but uses a `WHERE` clause to avoid even more curly braces:

[source,java,indent=0]
[[custom-queries-with-spel]]
.ARepository.java
----
include::../../../../src/test/java/org/springframework/data/neo4j/documentation/repositories/domain_events/ARepository.java[tags=spel]
----

The SpEL blocked starts with `:#{` and than refers to the given `String` parameters by name (`#pt1`).
Don't confuse this with the above Cypher syntax!
The SpEL expression concatenates both parameters into one single value that is eventually passed on to the <<neo4j-client>>.
The SpEL block ends with `}`.

SpEL also solves two additional problems. We provide two extensions that allow to pass in a `Sort` object into custom queries.
Remember <<custom-queries-with-page-and-slice-examples>> from <<faq.custom-queries,custom queries>>?
With the `orderBy` extension you can pass in a `Pageable` with a dynamic sort to a custom query:

[[custom-queries-with-spel-extensions]]
[source,java]
.orderBy-Extension
----
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.neo4j.repository.Neo4jRepository;
import org.springframework.data.neo4j.repository.query.Query;

public interface MyPersonRepository extends Neo4jRepository<Person, Long> {

    @Query(""
        + "MATCH (n:Person) WHERE n.name = $name RETURN n "
        + ":#{orderBy(#pageable)} SKIP $skip LIMIT $limit" // <.>
    )
    Slice<Person> findSliceByName(String name, Pageable pageable);

    @Query(""
        + "MATCH (n:Person) WHERE n.name = $name RETURN n :#{orderBy(#sort)}" // <.>
    )
    List<Person> findAllByName(String name, Sort sort);
}
----
<.> A `Pageable` has always the name `pageable` inside the SpEL context.
<.> A `Sort` has always the name `sort` inside the SpEL context.

The `literal` extension can be used to make things like labels or relationship-types "dynamic" in custom queries.
Neither labels nor relationship types can be parameterized in Cypher, so they must be given literal.

[source,java]
.literal-Extension
----
interface BaseClassRepository extends Neo4jRepository<BaseClass, Long> {

    @Query("MATCH (n:`:#{literal(#label)}`) RETURN n") // <.>
    List<Inheritance.BaseClass> findByLabel(String label);
}
----
<.> The `literal` extension will be replaced with the literal value of the evaluate parameter.
    Here it has been used to match dynamically on a Label.
    If you pass in `SomeLabel` as a parameter to the method, `MATCH (n:``SomeLabel``) RETURN n`
    will be generated. Ticks have been added to correctly escape values. SDN won't do this
    for you as this is probably not what you want in all cases.

[[faq.entities.auditing]]
== How do I audit entities?

All Spring Data annotations are supported.
Those are

* `org.springframework.data.annotation.CreatedBy`
* `org.springframework.data.annotation.CreatedDate`
* `org.springframework.data.annotation.LastModifiedBy`
* `org.springframework.data.annotation.LastModifiedDate`

[[faq.find-by-example]]
== How do I use "Find by example"?

"Find by example" is a new feature in SDN.
You instantiate an entity or use an existing one.
With this instance you create an `org.springframework.data.domain.Example`.
If your repository extends `org.springframework.data.neo4j.repository.Neo4jRepository` or `org.springframework.data.neo4j.repository.ReactiveNeo4jRepository`, you can immediately use the available `findBy` methods taking in an example, like shown in <<find-by-example-example>>

[source,java]
[[find-by-example-example]]
.findByExample in Action
----
Example<MovieEntity> movieExample = Example.of(new MovieEntity("The Matrix", null));
Flux<MovieEntity> movies = this.movieRepository.findAll(movieExample);

movieExample = Example.of(
	new MovieEntity("Matrix", null),
	ExampleMatcher
	    .matchingAny()
        .withMatcher(
        	"title",
        	ExampleMatcher.GenericPropertyMatcher.of(ExampleMatcher.StringMatcher.CONTAINING)
        )
);
movies = this.movieRepository.findAll(movieExample);
----

[[faq.path-mapping]]
== Can I map named paths?

A series of connected nodes and relationships is called a "path" in Neo4j.
Cypher allows paths to be named using an identifer, as exemplified by:

[source,cypher]
----
p = (a)-[*3..5]->(b)
----

or as in the infamous Movie graph, that includes the following path (in that case, one of the shortest path between two actors):

[[bacon-distance]]
[source,cypher]
.The "Bacon" distance
----
MATCH p=shortestPath((bacon:Person {name:"Kevin Bacon"})-[*]-(meg:Person {name:"Meg Ryan"}))
RETURN p
----

Which looks like this:

image::bacon-distance.png[]

We find 3 nodes labeled `Person` and 2 nodes labeled `Movie`. Both can be mapped with a custom queury.
Assume there's a node entity for both `Person` and `Movie` as well as `Actor` taking care of the relationship:


[source,java]
."Standard" movie graph domain model
----
@Node
public final class Person {

	@Id @GeneratedValue
	private final Long id;

	private final String name;

	private Integer born;

	@Relationship("REVIEWED")
	private List<Movie> reviewed = new ArrayList<>();
}

@RelationshipProperties
public final class Actor {

	@TargetNode
	private final Person person;

	private final List<String> roles;
}

@Node
public final class Movie {

	@Id
	private final String title;

	@Property("tagline")
	private final String description;

	@Relationship(value = "ACTED_IN", direction = Direction.INCOMING)
	private final List<Actor> actors;
}
----

When using a query as shown in <<bacon-distance>> for a domain class of type `Person` like this

[source,java]
----
interface PeopleRepository extends Neo4jRepository<Person, Long> {
    @Query(""
        + "MATCH p=shortestPath((bacon:Person {name: $person1})-[*]-(meg:Person {name: $person2}))\n"
        + "RETURN p"
    )
    List<Person> findAllOnShortestPathBetween(@Param("person1") String person1, @Param("person2") String person2);
}
----

it will retrieve all people from the path and map them.
If there are relationship types on the path like `REVIEWED` that are also present on the domain, these
will be filled accordingly from the path.

WARNING: Take special care when you use nodes hydrated from a path based query to save data.
         If not all relationships are hydrated, data will be lost.

The other way round works as well. The same query can be used with the `Movie` entity.
It then will only populate movies.
The following listing shows how todo this as well as how the query can be enriched with additional data
not found on the path. That data is used to correctly populate the missing relationships (in that case, all the actors)

[source,java]
----
interface MovieRepository extends Neo4jRepository<Movie, String> {

    @Query(""
        + "MATCH p=shortestPath(\n"
        + "(bacon:Person {name: $person1})-[*]-(meg:Person {name: $person2}))\n"
        + "WITH p, [n IN nodes(p) WHERE n:Movie] AS x\n"
        + "UNWIND x AS m\n"
        + "MATCH (m) <-[r:DIRECTED]-(d:Person)\n"
        + "RETURN p, collect(r), collect(d)"
    )
    List<Movie> findAllOnShortestPathBetween(@Param("person1") String person1, @Param("person2") String person2);
}
----

The query returns the path plus all relationships and related nodes collected so that the movie entities are fully hydrated.

The path mapping works for single paths as well for multiple records of paths (which are returned by the `allShortestPath` function.)

[[faq.spring-boot.sdn]]
== Do I need Spring Boot to use Spring Data Neo4j?

No, you don't.
While the automatic configuration of many Spring aspects through Spring Boot takes away a lot of manual cruft and is the recommended approach for setting up new Spring projects, you don't need to have to use this. 

The following dependency is required for the solutions described above:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
	<groupId>{neo4jGroupId}</groupId>
	<artifactId>{artifactId}</artifactId>
	<version>{spring-data-neo4j-version}</version>
</dependency>
----

The coordinates for a Gradle setup are the same.

To select a different database - either statically or dynamically - you can add a Bean of type `DatabaseSelectionProvider` as explained in <<faq.multidatabase>>.
For a reactive scenario, we provide `ReactiveDatabaseSelectionProvider`.

[[faq.sdn-without-spring-boot]]
=== Using Spring Data Neo4j inside a Spring context without Spring Boot

We provide two abstract configuration classes to support you in bringing in the necessary beans: `AbstractNeo4jConfig` for imperative database access and `AbstractReactiveNeo4jConfig` for the reactive version.
They are meant to be used with `@EnableNeo4jRepositories` and `@EnableReactiveNeo4jRepositories` respectively. 
See <<bootless-imperative-configuration>> and <<bootless-reactive-configuration>> for an example usage.
Both classes require you to override `driver()` in which you are supposed to create the driver.

To get the imperative version of the <<neo4j-client,Neo4j client>>, the template and support for imperative repositories, use something similar as shown here:

[source,java]
[[bootless-imperative-configuration]]
.Enabling Spring Data Neo4j infrastructure for imperative database access
----
import org.neo4j.driver.Driver;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import org.springframework.transaction.annotation.EnableTransactionManagement;

import org.springframework.data.neo4j.config.AbstractNeo4jConfig;
import org.springframework.data.neo4j.core.DatabaseSelectionProvider;
import org.springframework.data.neo4j.repository.config.EnableNeo4jRepositories;

@Configuration
@EnableNeo4jRepositories
@EnableTransactionManagement
class MyConfiguration extends AbstractNeo4jConfig {

    @Override @Bean
    public Driver driver() { // <.>
        return GraphDatabase.driver("bolt://localhost:7687", AuthTokens.basic("neo4j", "secret"));
    }

    @Override
    protected Collection<String> getMappingBasePackages() {
        return Collections.singletonList(Person.class.getPackage().getName());
    }

    @Override @Bean // <.>
    protected DatabaseSelectionProvider databaseSelectionProvider() {

        return DatabaseSelectionProvider.createStaticDatabaseSelectionProvider("yourDatabase");
    }
}
----
<.> The driver bean is required.
<.> This statically selects a database named `yourDatabase` and is *optional*.

The following listing provides the reactive Neo4j client and template, enables reactive transaction management and discovers Neo4j related repositories:

[source,java]
[[bootless-reactive-configuration]]
.Enabling Spring Data Neo4j infrastructure for reactive database access
----
import org.neo4j.driver.Driver;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.neo4j.config.AbstractReactiveNeo4jConfig;
import org.springframework.data.neo4j.repository.config.EnableReactiveNeo4jRepositories;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableReactiveNeo4jRepositories
@EnableTransactionManagement
class MyConfiguration extends AbstractReactiveNeo4jConfig {

    @Bean
    @Override
    public Driver driver() {
        return GraphDatabase.driver("bolt://localhost:7687", AuthTokens.basic("neo4j", "secret"));
    }

    @Override
    protected Collection<String> getMappingBasePackages() {
        return Collections.singletonList(Person.class.getPackage().getName());
    }
}
----

[[faq.sdn-in-cdi-2.0]]
=== Using Spring Data Neo4j in a CDI 2.0 environment

For your convenience we provide a CDI extension with `Neo4jCdiExtension`.
When run in a compatible CDI 2.0 container, it will be automatically be registered and loaded through https://docs.oracle.com/javase/tutorial/ext/basics/spi.html[Java's service loader SPI].

The only thing you have to bring into your application is an annotated type that produces the Neo4j Java Driver:

[source,java]
[[cdi-driver-producer]]
.A CDI producer for the Neo4j Java Driver
----
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Disposes;
import javax.enterprise.inject.Produces;

import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;

public class Neo4jConfig {

    @Produces @ApplicationScoped
    public Driver driver() { // <.>
        return GraphDatabase
            .driver("bolt://localhost:7687", AuthTokens.basic("neo4j", "secret"));
    }

    public void close(@Disposes Driver driver) {
        driver.close();
    }

    @Produces @Singleton
    public DatabaseSelectionProvider getDatabaseSelectionProvider() { // <.>
        return DatabaseSelectionProvider.createStaticDatabaseSelectionProvider("yourDatabase");
    }
}
----
<.> Same as with plain Spring in <<bootless-imperative-configuration>>, but annotated with the corresponding CDI infrastructure.
<.> This is *optional*. However, if you run a custom database selection provider, you _must_ not qualify this bean.

If you are running in a SE Container - like the one https://weld.cdi-spec.org[Weld] provides for example, you can enable the extension like that:

[source,java]
[[cdi-driver-producer-se]]
.Enabling the Neo4j CDI extension in a SE container
----
import javax.enterprise.inject.se.SeContainer;
import javax.enterprise.inject.se.SeContainerInitializer;

import org.springframework.data.neo4j.config.Neo4jCdiExtension;

public class SomeClass {
    void someMethod() {
        try (SeContainer container = SeContainerInitializer.newInstance()
                .disableDiscovery()
                .addExtensions(Neo4jCdiExtension.class)
                .addBeanClasses(YourDriverFactory.class)
                .addPackages(Package.getPackage("your.domain.package"))
            .initialize()
        ) {
            SomeRepository someRepository = container.select(SomeRepository.class).get();
        }
    }
}
----
