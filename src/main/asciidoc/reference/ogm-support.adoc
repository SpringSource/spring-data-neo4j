[[reference.ogm-support]]
= Neo4j-OGM Support

To get started, you need only your domain model and the annotations provided by the Neo4j-OGM library.
You use annotations to mark domain objects to be reflected by nodes and relationships of the graph database.
Annotations for individual fields allow you to declare how fields should be processed and mapped to properties of nodes in the graph.

Refer to the Neo4j-OGM documentation for more details.


[[introduction-graph-database]]
== What is Neo4j-OGM?

An OGM (Object Graph Mapper) maps nodes and relationships in the graph to objects and references in your domain model.
Object instances are mapped to nodes while object references are mapped using relationships, or serialized to properties.
JVM primitives are mapped to properties of a node or a relationship.
An OGM lets you create a view of your database based on your domain model.
It also provides the flexibility to supply custom queries in cases where the queries generated by Neo4j-OGM are insufficient.

The OGM can be thought of as analogous to Hibernate or JPA.
Users should have an understanding of what an object mapper does when using this guide.

While SDN's _repositories_ will cover a majority of user scenarios, sometimes they don't offer enough options.
Neo4j-OGM's `Session` offers a convenient API to interact more direct with a Neo4j graph database.
SDN now allows you to wire up the Neo4j-OGM `Session` directly into your Spring managed beans.

[[reference.architecture.session]]
=== Understanding the Session

A `Session` is used to drive the object-graph mapping framework.
All repository implementations are backed by the `Session`.
It keeps track of the changes that have been made to entities and their relationships.
The reason it does this is so that only entities and relationships that have changed get persisted on save, which is particularly efficient when working with large graphs.

Sessions are usually bound to a thread by default and rely on the garbage collector to clean them up once they are  out of scope of processing.
For most users this means there is nothing to configure.
Request/response type applications SDN will take care of session management for you (as defined in the configuration section above).
If you have a batch or long running desktop type application you may want to know how you can control using the session a bit more.

.Design Consideration: Session caching
****
Once an entity is tracked by the session, reloading this entity within the scope of the same session will result in the session cache returning the previously loaded entity.
However, the subgraph in the session will expand if the entity or its related entities retrieve additional relationships from the graph.

If you want to fetch fresh data from the graph, then this can be achieved by using a new session or clearing the current
sessions context using `org.neo4j.ogm.session.Session.clear()`.

The lifetime of the `Session` can be managed in code.
For example, associated with single _fetch-update-save_ cycle or unit of work.

If your application relies on long-running sessions then you may not see changes made from other users and find yourself working with outdated objects.
On the other hand, if your sessions have too narrow a scope then your save operations can be unnecessarily expensive, as updates will be made to all objects if the session isn't aware of the those that were originally loaded.

There's therefore a trade off between the two approaches.
In general, the scope of a `Session` should correspond to a "unit of work" in your application.
****

== Basic Operations

For Spring Data Neo4j, low level operations are handled by Neo4j-OGM `Session`.
Basic operations are limited to CRUD operations on entities and executing arbitrary Cypher queries; more low-level manipulation of the graph database is not possible.

Given that the latest version of the framework is driven by Cypher queries alone, there's no way to work directly with `Node` and `Relationship` objects, especially in remote server mode.
Similarly, the `traverse()` method has disappeared, again because the underlying query-driven model doesn't handle it in an efficient way.

If you did rely on low-level manipulation of the graph database itself or being able to use `travers()` in previous versions of Spring Data Neo4j, then your best options are:

. Write a Cypher query to perform the operations on the nodes/relationships instead
. Write a Neo4j server extension and call it over REST from your application

Of course, there are pros and cons to both of these approaches, but these are largely outside the scope of this document.
In general, for low-level, very high-performance operations like complex graph traversals you will get the best performance by writing a server-side extension.
For most purposes, though, Cypher will be performant and expressive enough to perform the operations that you need.

== Entity Persistence

`Session` allows you to `save`, `load`, `loadAll` and `delete` entities.
The eagerness with which objects are retrieved is controlled by specifying the 'depth' argument to any of the load methods.

All of these basic CRUD methods just call onto the underlying methods of `Session`, albeit with transaction handling and exception translation managed for you by SDN's `TransactionManager` bean.

== Cypher Queries

The `Session` also allows execution of arbitrary Cypher queries via its `query`, `queryForObject` and `queryForObjects` methods.
Cypher queries that return tabular results should be passed into the `query` method.
An `org.neo4j.ogm.session.result.Result` is returned.
This consists of `org.neo4j.ogm.session.result.QueryStatistics` representing statistics of modifying cypher statements if applicable,
and an `Iterable<Map<String,Object>>` containing the raw data, of which nodes and relationships are mapped to domain entities if possible.
The keys in each `Map` correspond to the names listed in the return clause of the executed Cypher query.

[NOTE]
Modifications made to the graph via Cypher queries directly will not be reflected in your domain objects within the session.


== Transactions

If you configured the `Neo4jTransactionManager` bean, any `Session` that is managed by Spring will automatically take part in thread contextual transactions.
In order to do this you will need to wrap your service code using `@Transactional` or the `TransactionTemplate`.

[NOTE]
It is important to know that if you enable Transactions *ALL* code that uses the `Session` directly must be enclosed in a `@Transactional` annotation.
Declarative Spring Data repositories (see <<neo4j.repositories>>) are already marked as `@Transactional` and will create implicit transactions if no transaction boundaries are defined at the callers site.

For more details see <<reference_programming-model_transactions,Transactions>>
